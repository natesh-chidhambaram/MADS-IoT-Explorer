defmodule AcqdatCore.Metrics.Reports do
  import Ecto.Query

  alias AcqdatCore.Repo
  alias AcqdatCore.Schema.Metrics
  alias AcqdatCore.Metrics.OrgMetrics

  alias AcqdatCore.Schema.EntityManagement.Organisation

  @moduledoc """
  A module for handling all the organisation related metrics.

  The module handles the core logic to aggregate organisation metrics.
  An organisation has the following artifacts which needs to be tracked:
  - `Projects` See `AcqdatCore.Schema.EntityManagement.Project`
  - `Assets` See `AcqdatCore.Schema.EntityManagement.Asset`
  - `Sensors` See `AcqdatCore.Schema.EntityManagement.Sensor`
  - `AssetTypes` See `AcqdatCore.Schema.EntityManagement.AssetType`
  - `SensorTypes` See `AcqdatCore.Schema.EntityManagement.SensorType`
  - `Gateways` See `AcqdatCore.Schema.IotManager.Gateway`
  - `Active Parameters`
  - `Dashboards` See `AcqdatCore.DashboardManagement.Schema.Dashboard`
  - `Data Insights Fact Tabkes` See See `AcqdatCore.DataInsights.Schema.FactTables`
  - `Data Insights Visualisations` See `AcqdatCore.DataInsights.Schema.Visualizations`

  Other than above entities certain more attrbutes are tracked such as:
  - `Active Parameters`: Number of sensor parameters which are receiving data on a
  daily basis
  - `Reports Download`: Number of reports being donwloaded from the dashboard.

  Other than above parameters there should be a provision to monitor the bandwidth
  and data storage being consumed by an organisation.

  The following entities are logged on a daily basis to keep a track of the
  artifacts being generated by the users of an organisation. The artifacts are
  then aggregated monthly to give an insight into resource usage per organisation.

  ## Algorithm
  The current algorithm checks all the above artifacts being created for an
  organisation and then logs them. The logs are then aggregated every month for
  or uptil the given date to give the trends for a specific month.
  """
  @doc """
  Returns the monthly report for an organisation.

  Expects a month in the integer representation or a date as the input.
  """
  def range_report(org_id, start_date, end_date, type, app, entity, group_action)
      when type == "column" do
    number_of_days = Date.diff(end_date, start_date)

    grp_parms = if group_action == "weekly", do: "7 days", else: "30 days"

    query =
      from(
        metric in Metrics,
        where:
          metric.org_id == ^org_id and
            fragment("?::date BETWEEN ? AND ?", metric.inserted_time, ^start_date, ^end_date),
        group_by: fragment("date_filt"),
        select: [
          fragment(
            "EXTRACT(EPOCH FROM (time_bucket(?::VARCHAR::INTERVAL, ?)))*1000 as date_filt",
            ^grp_parms,
            metric.inserted_time
          ),
          fragment("sum((? -> ? -> ? -> 'count')::integer)", metric.metrics, ^app, ^entity) /
            fragment("count(*)")
        ]
      )

    {:ok, Repo.all(query)}
  end

  def fetch_data(org_id, start_date, end_date, filter_metadata) do
    out =
      Enum.reduce(filter_metadata, "", fn set, acc ->
        set["app"]
        set["entity"]

        "a0.metrics -> '#{set["app"]}' -> '#{set["entity"]}' -> 'count' as \"#{set["entity"]} count\"," <>
          acc
      end)

    out = String.slice(out, 0..-2)

    res = """
    SELECT a0."inserted_time"::VARCHAR, #{out}
    FROM "acqdat_metrics" AS a0 WHERE ((a0."org_id" = #{org_id}) AND
    a0."inserted_time"::date BETWEEN \'#{start_date}\' AND \'#{end_date}\')
    """

    Ecto.Adapters.SQL.query!(Repo, res, [])
  end

  def range_report(org_id, start_date, end_date, type, group_action) when type == "cards" do
    query =
      from(
        metric in Metrics,
        where:
          metric.org_id == ^org_id and
            fragment("?::date BETWEEN ? AND ?", metric.inserted_time, ^start_date, ^end_date),
        distinct: fragment("?::date", metric.inserted_time)
      )

    {new_report, number_of_days} = report_computation(query)

    if number_of_days == 0 do
      {:error, "Data missing for organisation on some days, cannot generate report"}
    else
      {:ok,
       %{
         dashboard: %{
           dashboard_count: round(new_report.dashboard_count / number_of_days),
           panel_count: round(new_report.panel_count / number_of_days),
           widget_count: round(new_report.widget_count / number_of_days)
         },
         data_insights: %{
           fact_table_count: round(new_report.fact_table_count / number_of_days),
           visualisation_count: round(new_report.visualisation_count / number_of_days)
         },
         role_manager: %{
           user_count: round(new_report.user_count / number_of_days)
         },
         entities: %{
           active_parameter_count: round(new_report.active_parameter_count / number_of_days),
           asset_type_count: round(new_report.asset_type_count / number_of_days),
           asset_count: round(new_report.asset_count / number_of_days),
           gateway_count: round(new_report.gateway_count / number_of_days),
           project_count: round(new_report.project_count / number_of_days),
           sensor_type_count: round(new_report.sensor_type_count / number_of_days),
           sensor_count: round(new_report.sensor_count / number_of_days)
         }
       }}
    end
  end

  def range_report(org_id, start_date, end_date, type, group_action) when type == "list" do
    grp_parms = if group_action == "weekly", do: "7 days", else: "30 days"

    query =
      from(
        metric in Metrics,
        where:
          metric.org_id == ^org_id and
            fragment("?::date BETWEEN ? AND ?", metric.inserted_time, ^start_date, ^end_date),
        group_by: fragment("date_filt"),
        select: %{
          date_time:
            fragment(
              "time_bucket(?::VARCHAR::INTERVAL, ?) as date_filt",
              ^grp_parms,
              metric.inserted_time
            ),
          dashboards:
            fragment(
              "sum((? -> 'dashboards' -> 'dashboards' -> 'count')::integer)",
              metric.metrics
            ) / fragment("count(*)"),
          widgets:
            fragment("sum((? -> 'dashboards' -> 'widgets' -> 'count')::integer)", metric.metrics) /
              fragment("count(*)"),
          panels:
            fragment("sum((? -> 'dashboards' -> 'panels' -> 'count')::integer)", metric.metrics) /
              fragment("count(*)"),
          fact_tables:
            fragment(
              "sum((? -> 'data_insights' -> 'fact_tables' -> 'count')::integer)",
              metric.metrics
            ) / fragment("count(*)"),
          visualisations:
            fragment(
              "sum((? -> 'data_insights' -> 'visualisations' -> 'count')::integer)",
              metric.metrics
            ) / fragment("count(*)"),
          active_parameters:
            fragment(
              "sum((? -> 'entities' -> 'active_parameters' -> 'count')::integer)",
              metric.metrics
            ) / fragment("count(*)"),
          asset_types:
            fragment(
              "sum((? -> 'entities' -> 'asset_types' -> 'count')::integer)",
              metric.metrics
            ) / fragment("count(*)"),
          assets:
            fragment("sum((? -> 'entities' -> 'assets' -> 'count')::integer)", metric.metrics) /
              fragment("count(*)"),
          sensor_types:
            fragment(
              "sum((? -> 'entities' -> 'sensor_types' -> 'count')::integer)",
              metric.metrics
            ) / fragment("count(*)"),
          sensors:
            fragment("sum((? -> 'entities' -> 'sensors' -> 'count')::integer)", metric.metrics) /
              fragment("count(*)"),
          gateways:
            fragment("sum((? -> 'entities' -> 'gateways' -> 'count')::integer)", metric.metrics) /
              fragment("count(*)"),
          projects:
            fragment("sum((? -> 'entities' -> 'projects' -> 'count')::integer)", metric.metrics) /
              fragment("count(*)"),
          users:
            fragment("sum((? -> 'role_manager' -> 'users' -> 'count')::integer)", metric.metrics) /
              fragment("count(*)")
        }
      )

    res = Repo.all(query)
    {:ok, res}
  end

  # TODO: Needs to refactor this code
  def range_report(org_id, start_date, end_date, type, group_action) when type == "highlights" do
    grp_parms = if group_action == "weekly", do: "7 days", else: "30 days"

    query =
      from(
        metric in Metrics,
        where:
          metric.org_id == ^org_id and
            fragment("?::date BETWEEN ? AND ?", metric.inserted_time, ^start_date, ^end_date),
        group_by: fragment("date_filt"),
        select: %{
          date_time:
            fragment(
              "time_bucket(?::VARCHAR::INTERVAL, ?) as date_filt",
              ^grp_parms,
              metric.inserted_time
            ),
          days_count: fragment("count(*)"),
          dashboards:
            fragment(
              "sum((? -> 'dashboards' -> 'dashboards' -> 'count')::integer)",
              metric.metrics
            ),
          widgets:
            fragment("sum((? -> 'dashboards' -> 'widgets' -> 'count')::integer)", metric.metrics),
          panels:
            fragment("sum((? -> 'dashboards' -> 'panels' -> 'count')::integer)", metric.metrics),
          fact_tables:
            fragment(
              "sum((? -> 'data_insights' -> 'fact_tables' -> 'count')::integer)",
              metric.metrics
            ),
          visualisations:
            fragment(
              "sum((? -> 'data_insights' -> 'visualisations' -> 'count')::integer)",
              metric.metrics
            ),
          active_parameters:
            fragment(
              "sum((? -> 'entities' -> 'active_parameters' -> 'count')::integer)",
              metric.metrics
            ),
          asset_types:
            fragment(
              "sum((? -> 'entities' -> 'asset_types' -> 'count')::integer)",
              metric.metrics
            ),
          assets:
            fragment("sum((? -> 'entities' -> 'assets' -> 'count')::integer)", metric.metrics),
          sensor_types:
            fragment(
              "sum((? -> 'entities' -> 'sensor_types' -> 'count')::integer)",
              metric.metrics
            ),
          sensors:
            fragment("sum((? -> 'entities' -> 'sensors' -> 'count')::integer)", metric.metrics),
          gateways:
            fragment("sum((? -> 'entities' -> 'gateways' -> 'count')::integer)", metric.metrics),
          projects:
            fragment("sum((? -> 'entities' -> 'projects' -> 'count')::integer)", metric.metrics),
          users:
            fragment("sum((? -> 'role_manager' -> 'users' -> 'count')::integer)", metric.metrics)
        }
      )

    res = Repo.all(query)

    if length(res) == 2 do
      highlights = %{}
      lowlights = %{}
      [%{days_count: prev_days_count} = prev, %{days_count: curr_days_count} = curr] = res
      curr_dash = comp_avg(curr.dashboards, curr_days_count)
      prev_dash = comp_avg(prev.dashboards, prev_days_count)
      lowlights = entity_lowlights_comp(lowlights, curr_dash, prev_dash, :dashboards)
      highlights = entity_hightlights_comp(highlights, curr_dash, prev_dash, :dashboards)

      curr_dash = comp_avg(curr.widgets, curr_days_count)
      prev_dash = comp_avg(prev.widgets, prev_days_count)
      lowlights = entity_lowlights_comp(lowlights, curr_dash, prev_dash, :widgets)
      highlights = entity_hightlights_comp(highlights, curr_dash, prev_dash, :widgets)

      curr_dash = comp_avg(curr.panels, curr_days_count)
      prev_dash = comp_avg(prev.panels, prev_days_count)
      lowlights = entity_lowlights_comp(lowlights, curr_dash, prev_dash, :panels)
      highlights = entity_hightlights_comp(highlights, curr_dash, prev_dash, :panels)

      curr_dash = comp_avg(curr.fact_tables, curr_days_count)
      prev_dash = comp_avg(prev.fact_tables, prev_days_count)
      lowlights = entity_lowlights_comp(lowlights, curr_dash, prev_dash, :fact_tables)
      highlights = entity_hightlights_comp(highlights, curr_dash, prev_dash, :fact_tables)

      curr_dash = comp_avg(curr.visualisations, curr_days_count)
      prev_dash = comp_avg(prev.visualisations, prev_days_count)
      lowlights = entity_lowlights_comp(lowlights, curr_dash, prev_dash, :visualisations)
      highlights = entity_hightlights_comp(highlights, curr_dash, prev_dash, :visualisations)

      curr_dash = comp_avg(curr.active_parameters, curr_days_count)
      prev_dash = comp_avg(prev.active_parameters, prev_days_count)
      lowlights = entity_lowlights_comp(lowlights, curr_dash, prev_dash, :active_parameters)
      highlights = entity_hightlights_comp(highlights, curr_dash, prev_dash, :active_parameters)

      curr_dash = comp_avg(curr.assets, curr_days_count)
      prev_dash = comp_avg(prev.assets, prev_days_count)
      lowlights = entity_lowlights_comp(lowlights, curr_dash, prev_dash, :assets)
      highlights = entity_hightlights_comp(highlights, curr_dash, prev_dash, :assets)

      curr_dash = comp_avg(curr.visualisations, curr_days_count)
      prev_dash = comp_avg(prev.visualisations, prev_days_count)
      lowlights = entity_lowlights_comp(lowlights, curr_dash, prev_dash, :visualisations)
      highlights = entity_hightlights_comp(highlights, curr_dash, prev_dash, :visualisations)

      curr_dash = comp_avg(curr.sensor_types, curr_days_count)
      prev_dash = comp_avg(prev.sensor_types, prev_days_count)
      lowlights = entity_lowlights_comp(lowlights, curr_dash, prev_dash, :sensor_types)
      highlights = entity_hightlights_comp(highlights, curr_dash, prev_dash, :sensor_types)

      curr_dash = comp_avg(curr.sensors, curr_days_count)
      prev_dash = comp_avg(prev.sensors, prev_days_count)
      lowlights = entity_lowlights_comp(lowlights, curr_dash, prev_dash, :sensors)
      highlights = entity_hightlights_comp(highlights, curr_dash, prev_dash, :sensors)

      curr_dash = comp_avg(curr.gateways, curr_days_count)
      prev_dash = comp_avg(prev.gateways, prev_days_count)
      lowlights = entity_lowlights_comp(lowlights, curr_dash, prev_dash, :gateways)
      highlights = entity_hightlights_comp(highlights, curr_dash, prev_dash, :gateways)

      curr_dash = comp_avg(curr.projects, curr_days_count)
      prev_dash = comp_avg(prev.projects, prev_days_count)
      lowlights = entity_lowlights_comp(lowlights, curr_dash, prev_dash, :projects)
      highlights = entity_hightlights_comp(highlights, curr_dash, prev_dash, :projects)

      curr_dash = comp_avg(curr.users, curr_days_count)
      prev_dash = comp_avg(prev.users, prev_days_count)
      lowlights = entity_lowlights_comp(lowlights, curr_dash, prev_dash, :users)
      highlights = entity_hightlights_comp(highlights, curr_dash, prev_dash, :users)

      {:ok, %{highlights: highlights, lowlights: lowlights}}
    else
      {:error, "Data missing for organisation on some days, cannot generate report"}
    end
  end

  defp report_computation(query) do
    report_map = %{
      dashboard_count: 0,
      panel_count: 0,
      widget_count: 0,
      fact_table_count: 0,
      visualisation_count: 0,
      active_parameter_count: 0,
      asset_type_count: 0,
      asset_count: 0,
      gateway_count: 0,
      project_count: 0,
      sensor_type_count: 0,
      sensor_count: 0,
      user_count: 0
    }

    results = Repo.all(query)

    new_report =
      Enum.reduce(results, report_map, fn daily_report, new_report ->
        dashboard_count =
          new_report.dashboard_count +
            Map.fetch!(daily_report.metrics.dashboards.dashboards, "count")

        panel_count =
          new_report.panel_count + Map.fetch!(daily_report.metrics.dashboards.panels, "count")

        widget_count =
          new_report.widget_count +
            Map.fetch!(daily_report.metrics.dashboards.widgets, "count")

        fact_table_count =
          new_report.fact_table_count +
            Map.fetch!(daily_report.metrics.data_insights.fact_tables, "count")

        visualisation_count =
          new_report.visualisation_count +
            Map.fetch!(daily_report.metrics.data_insights.visualisations, "count")

        active_parameter_count =
          new_report.active_parameter_count +
            Map.fetch!(daily_report.metrics.entities.active_parameters, "count")

        asset_type_count =
          new_report.asset_type_count +
            Map.fetch!(daily_report.metrics.entities.asset_types, "count")

        asset_count =
          new_report.asset_count + Map.fetch!(daily_report.metrics.entities.assets, "count")

        gateway_count =
          new_report.gateway_count +
            Map.fetch!(daily_report.metrics.entities.gateways, "count")

        project_count =
          new_report.project_count +
            Map.fetch!(daily_report.metrics.entities.projects, "count")

        sensor_type_count =
          new_report.sensor_type_count +
            Map.fetch!(daily_report.metrics.entities.sensor_types, "count")

        sensor_count =
          new_report.sensor_count + Map.fetch!(daily_report.metrics.entities.sensors, "count")

        user_count =
          new_report.user_count + Map.fetch!(daily_report.metrics.role_manager.users, "count")

        %{
          new_report
          | dashboard_count: dashboard_count,
            panel_count: panel_count,
            widget_count: widget_count,
            fact_table_count: fact_table_count,
            visualisation_count: visualisation_count,
            active_parameter_count: active_parameter_count,
            asset_type_count: asset_type_count,
            asset_count: asset_count,
            gateway_count: gateway_count,
            project_count: project_count,
            sensor_type_count: sensor_type_count,
            sensor_count: sensor_count,
            user_count: user_count
        }
      end)

    {new_report, length(results)}
  end

  defp comp_avg(entity, tot) do
    round(entity / tot)
  end

  defp entity_hightlights_comp(highlights, curr, prev, entity) do
    if curr >= prev,
      do: Map.put(highlights, entity, %{value: curr, diff: curr - prev}),
      else: highlights
  end

  defp entity_lowlights_comp(lowlights, curr, prev, entity) do
    if curr <= prev,
      do: Map.put(lowlights, entity, %{value: curr, diff: prev - curr}),
      else: lowlights
  end
end
